# c_w_var2
## номер 1
Написать программу, которая читает из стандартного потока ввода произвольный текст до поступления ситуации "конец файла" и запоминает, какие слова встречались в тексте, после чего (то есть после окончания ввода) определяет максимальную длину слова среди всех встреченных и печатает в стандартный поток вывода все слова из введенного текста, имеющие эту макимальную длину (например, если встречено хотя бы одно слово длиной в 15 символов, но ни одного более длинного, то нужно напечатать все слова, встретившиеся в тексте и имевшие длину 15 символов). Под словом понимается любая последовательность цифр и латинских букв. Все остальные символы считаются разделительными и в слова не входят. Вводить какие-либо явные ограничения на длину строк, слов и всего текста запрещается.
## номер 2
Получить через аргументы комадной строки имена и аргументы для запуска двух программ, разделенные словом "---"; например, если ваша программа называется prog и пользователь вводит
./prog ls -l -R --- yes abc
то это значит, что нужно запустить программу ls с аргументами -l -R и программу yes с аргументом abc.
Запустить заданные программы на одновременное (параллельное) использование так, чтобы каждая вторая строка, напечатанная первой программой, поступала на стандратный ввод второй рпограммы (то есть одну строку игнорируем, вторую подаем на вход второй программе, и т.д.). ПОДСКАЗКА: для решения этой задачи необходим третий процесс.
## номер 3
Написать программу, которая получает через аргументы командной строки имена двух файлов, а также имя и аргументы для запуска внешней программы, запускает эту внешнюю программу с заданными аргументами. перенаправив стандартный ввод из первого файла, а стандартный вывод - во второй файл (ПОДСКАЗКА: в качестве аргументов execvp можно использовать непосредственно argv[3] и argv+3) и обеспечив для порожденного процесса игнорирование сигнала SIGINT (ПОДСКАЗКА: игнорирующая диспозиция для сигнала наследуется через exec). При нажатии Ctrl-C ваша программа приоставливает работу дочернего процесса, отправив ему сигнал SIGSTOP, при повторном нажатии Ctrl-C - возобновляет работу дочернего процесса, отправив ему сигнал SIGCONT. При нажатии Ctrl-C дважды с интервалом менее одной секунды - уничтожает дочерний процесс сигналом SIGKILL (отследить интервал можно с помощью вызова alarm и обработки сигнала SIGALRM, либо путем запуска дополнительного процесса, который через секунду пришлет некий сигнал своему родителю, либо другим способом). При завершении дочернего процесса ваша программа обязана немедленно завершиться (если ваш родительский процесс использует блокирубщие системные вызовы, то это может быть достигнуто обработкой сигнала SIGCHLD, если нет - то простым вызовом wait). Для тестирования рекомендруется использовать файлы типа FIFO, которые можно создать командой mkfifo.
